# remote-control
Android端控制PC
功能: 远程鼠标的控制，自定义按键映射, 普通文本，dos消息的发送，远程电源控制，远程文件下载与本地文件上传...
## 启动步骤
```
1.运行RemoteServer里面的jar文件
2.手机端输入对应PC的IP地址和端口号
tips: 两者必须在一个局域网内
```
```
为了方便日常使用 可以配置下环境变量 在Linux下直接把jar包扔到/usr/bin里面 然后在该目录新建一个脚本文件
sudo vim /usr/bin/remote-server
输入以下内容
#!/bin/s  h
java -jar /usr/bin/RemoteServer.jar
然后设置可执行权限
sudo chmod +x remote-server
这样就可以直接在终端输入命令 启动服务器端
```
## 基本实现简述
初始建立连接时，使用的是TCP协议来进行的，里面其它所有的事件，消息收发都是使用的UDP协议，因为这些数据丢包是可以容忍的。另外,文件上传与下载是使用的TCP协议, 普通消息一次包就可发送过去，文件比较大时必须分片的发送，并且文件发送丢包的话，已经接收的数据与后续需要传输的数据就都没太大意义了,TCP能保证数据包的可达. 消息的发送，连接的建立等都是交给线程池去进行操作的, 而消息的接收单独使用了一个线程. 

## 更新
把原来单线程文件传输切换成多线程文件传输，并且支持断点续传，更改原来上传和下载包的混乱，文件请求统一采用**FileRequestPacket**，具体的收发过程都切换成**FileDownloadRequestPacket**和**FileDownloadResponsePacket**来进行通知. 这里再说明一下， 具体的实现过程出现的一些坑。 接收到下载通知后， 主要是交给**MultiThreadDownloadTask**类去进行具体文件的分片、上次读取到的位置续传、具体文件片段请求的发送，并且还要使用额外的一个临时文件记录已经下载大进度。之前采用的是UDP发送一般的请求和响应包，并且我要实现多线程传输想最大程度的利用原先的代码，所以其实**MultiThreadDownloadTask**类与接收下载响应包无关联，所以首先需要解决的问题是将每个具体的下载请求与该类关联，才方便进行进度条等全局信息的获取，这里使用了**CountDownLatch**进行计数。第二个较大的问题是，我建立的连接可能与响应包对应错误，这样会导致接收到的数据片乱序，所以先给每个分片一个**seq**表示序列，然后用一个新的类**DonwloadScheduler**把接收到的下载响应包丢入一个队列，然后建立连接时服务器端会发送对应包的**seq**，这样在客户端接收后就方便与连接进行绑定进行绑定，用单独的一个线程轮询队列，保证接收到的包有对应的建立好的连接，此时就可以开始真正的写了。最后一个问题，文件片段较大时，如果客户端跟服务器端建立连接就开始写，客户端对应的连接如果比较迟才将绑定完成，最后接收数据时可能会导致服务器端早就写了较多的数据，但一直没被接收，会导致连接非正常关闭，所以最好在确定客户端能进行收发后再通知服务器开始发送数据。

最后，一般能提速下载主要是由于单线程带宽利用率低，丢包时CPU等待时间较长，这样用多线程就能减少等待时间，所以在局域网内一般不会丢包，速度基本没多大差别. 理论感觉简单，实践起来代码又要保证不混乱，坑还是挺多的，特别是多线程情况下要快速定位问题就必须要考虑清楚行为可能产生的结果，此时断点是不太方便进行调试的，但可以用较少的数据和线程数量进行打印输出.
## 参考
https://github.com/varunon9/Remote-Control-PC.git
